/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50627
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50627
File Encoding         : 65001

Date: 2019-01-13 14:26:03
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `blog`
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog` (
  `bid` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `summary` varchar(300) DEFAULT NULL COMMENT '摘要',
  `releaseDate` datetime DEFAULT NULL COMMENT '发布时间',
  `author` varchar(255) DEFAULT NULL COMMENT '发布人',
  `clickHit` int(11) DEFAULT NULL COMMENT '查看次数',
  `replyHit` int(11) DEFAULT NULL COMMENT '回复次数',
  `content` text COMMENT '内容',
  `keyWord` varchar(255) DEFAULT NULL,
  `typeId` int(11) DEFAULT NULL COMMENT '外键',
  PRIMARY KEY (`bid`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('1', '死磕java并发', '作为一个javaweb应用的开发者，你快速学习了request（HttpRequest）和Session（HttpSession）的范围，理解这些范围并且在这些范围内数据和对象是如何是进出的对设计和构建web应用是非常关键的。springMVC的范围当我用springMVC写web应用的时候，我发现sprin', '2017-07-24 17:30:06', '赖红', '5', '0', '<p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/></p>', 'java', '2');
INSERT INTO `blog` VALUES ('2', '测试', '作为一个javaweb应用的开发者，你快速学习了request（HttpRequest）和Session（HttpSession）的范围，理解这些范围并且在这些范围内数据和对象是如何是进出的对设计和构建web应用是非常关键的。springMVC的范围当我用springMVC写web应用的时候，我发现sprin', '2017-07-24 21:11:46', '赖红', '0', '0', '<p>作为一个javaweb应用的开发者，你快速学习了request（HttpRequest）和Session（HttpSession）的范围，理解这些范围并且在这些范围内数据和对象是如何是进出的对设计和构建web应用是非常关键的。</p><h3><a target=\"_blank\" name=\"t0\"></a>springMVC的范围</h3><p>当我用springMVC写web应用的时候，我发现spring model和session有一点神秘—特别是与http \nreques、和session范围关联起来这些我都已经了解了。spring的model元素会在我的session或者request中找到吗，如果是这样，我怎么控制这个过程呢，在这篇文章中我希望能够解密springMVC的model和session是如何工作的。</p><h3><a target=\"_blank\" name=\"t1\"></a>spring的@MODELATTRIBUTE</h3><p>这里有好几种向spring的Model添加数据的方式。数据或者对象通常通过在controller上的注释方法添加到spring中的model中去。下边这个例子中，@ModelAttribute用来将MyCommandBean的实例以key值为myRequestObject添加到model中去</p><p><br/></p>', '测试', '4');
INSERT INTO `blog` VALUES ('3', '再次测试', '结果集更好的开发开放叽叽咕咕那边结果集国家机关伽利略的开发结构和vjgnfjdkk开发开放两个体乳添加功能的方法该的附件附件里日俄我IEUR个很警示警示究极风暴那个就回复方法看看啊啊啊啊啊啊啊奥奥奥奥奥奥奥奥奥扩付扩扩非空空过军军军军付', '2017-07-25 22:17:33', '赖红', '10', '1', '<p>结果集更好的开发开放叽叽咕咕那边结果集国家机关伽利略的开发结构和vjgnfjdkk开发开放两个体乳添加功能的方法该的附件附件里日俄我IEUR个很警示警示究极风暴那个就回复方法看看啊啊啊啊啊啊啊奥奥奥奥奥奥奥奥奥扩付扩扩非空空过军军军军付</p><p><img src=\"http://localhost:8080/ssm/static/userImages/20170725/1500992207010068332.jpg\" title=\"1500992207010068332.jpg\" alt=\"mmexport1485769444198.jpg\"/></p>', '再次测试', '2');
INSERT INTO `blog` VALUES ('4', '测试', '测试测试', '2017-07-25 22:55:50', '赖红', '0', '0', '<p>测试测试<br/></p>', '测试', '2');
INSERT INTO `blog` VALUES ('5', 'JAVA内存模型之总结', '总结JMM规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序。一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。JMM对程序员屏蔽了CPU以及OS内存的使用问题，能够使程序在不同的CPU和OS内存上都能够达到预期的效果。Java采用内存共享', '2017-07-26 11:40:16', '赖红', '5', '0', '<h2 id=\"总结\">总结</h2><p>JMM规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序。一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。JMM对程序员屏蔽了CPU以及OS内存的使用问题，能够使程序在不同的CPU和OS内存上都能够达到预期的效果。</p><p>Java采用内存共享的模式来实现线程之间的通信。编译器和处理器可以对程序进行重排序优化处理，但是需要遵守一些规则，不能随意重排序。</p><p><strong>原子性</strong>：一个操作或者多个操作要么全部执行要么全部不执行；</p><p><strong>可见性</strong>：当多个线程同时访问一个共享变量时，如果其中某个线程更改了该共享变量，其他线程应该可以立刻看到这个改变；</p><p><strong>有序性</strong>：程序的执行要按照代码的先后顺序执行；</p><p>在并发编程模式中，势必会遇到上面三个概念，JMM对原子性并没有提供确切的解决方案，但是JMM解决了可见性和有序性，至于原子性则需要通过锁或者Synchronized来解决了。</p><p>如果一个操作A的操作结果需要对操作B可见，那么我们就认为操作A和操作B之间存在happens-before关系，即A happens-before B。</p><p>happens-before原则是JMM中非常重要的一个原则，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以解决在并发环境下两个操作之间是否存在冲突的所有问题。JMM规定，两个操作存在happens-before关系并不一定要A操作先于B操作执行，只要A操作的结果对B操作可见即可。</p><p>在程序运行过程中，为了执行的效率，编译器和处理器是可以对程序进行一定的重排序，但是他们必须要满足两个条件：1 执行的结果保持不变，2 存在数据依赖的不能重排序。重排序是引起多线程不安全的一个重要因素。</p><p>同时顺序一致性是一个比较理想化的参考模型，它为我们提供了强大而又有力的内存可见性保证，他主要有两个特征：1 \n一个线程中的所有操作必须按照程序的顺序来执行；2 \n所有线程都只能看到一个单一的操作执行顺序，在顺序一致性模型中，每个操作都必须原则执行且立刻对所有线程可见。</p><p><br/></p>', 'java 线程', '2');
INSERT INTO `blog` VALUES ('6', 'java内存模型之JMM角度分析DCL', '如果检查第一个singleton不为null,则不需要执行下面的加锁动作，极大提高了程序的性能；如果第一个singleton为null,即使有多个线程同一时间判断，但是由于synchronized的存在，只会有一个线程能够创建对象；当第一个获取锁的线程创建完成后singleton对象后，其他的在第二次判断si', '2017-07-26 12:43:24', '湛颖鸿', '19', '6', '<ul class=\" list-paddingleft-2\"><li><p>如果检查第一个singleton不为null,则不需要执行下面的加锁动作，极大提高了程序的性能；</p></li><li><p>如果第一个singleton为null,即使有多个线程同一时间判断，但是由于synchronized的存在，只会有一个线程能够创建对象；</p></li><li><p>当第一个获取锁的线程创建完成后singleton对象后，其他的在第二次判断singleton一定不会为null，则直接返回已经创建好的singleton对象；</p></li></ul><p>通过上面的分析，DCL看起确实是非常完美，但是可以明确地告诉你，这个错误的。上面的逻辑确实是没有问题，分析也对，但是就是有问题，那么问题出在哪里呢？在回答这个问题之前，我们先来复习一下创建对象过程，实例化一个对象要分为三个步骤：</p><ol class=\" list-paddingleft-2\"><li><p>分配内存空间</p></li><li><p>初始化对象</p></li><li><p>将内存空间的地址赋值给对应的引用</p></li></ol><p>但是由于重排序的缘故，步骤2、3可能会发生重排序，其过程如下：</p><ol class=\" list-paddingleft-2\"><li><p>分配内存空间</p></li><li><p>将内存空间的地址赋值给对应的引用</p></li><li><p>初始化对象</p></li></ol><p>如果2、3发生了重排序就会导致第二个判断会出错，singleton != null，但是它其实仅仅只是一个地址而已，此时对象还没有被初始化，所以return的singleton对象是一个没有被初始化的对象，如下：</p><p><img src=\"http://localhost:8080/ssm/static/userImages/20170726/1501044173490074320.jpg\" title=\"1501044173490074320.jpg\" alt=\"mmexport1485270570321.jpg\"/></p><p><br/></p>', 'java 线程 对象', '2');
INSERT INTO `blog` VALUES ('8', '网站开发进阶——中文字符编码问题', '中文字符编码问题前言      遇到的问题千奇百怪，在往MySQL数据表存储带有中文字符的字符串时显示乱码。经过代码输出测试发现插入语句如下：       在数据库内查询，发现存储的内容为乱码。       尝试在mysql中直接插入语句。如下:      INSERT INTO lm_user_med (u', '2017-08-03 16:56:40', '吴铭明', '1', '0', '<h1 style=\"text-align: center;\"><strong>中文字符编码问题</strong></h1><h2><a target=\"_blank\" name=\"t1\"></a><strong>前言</strong></h2><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; 遇到的问题千奇百怪，在往<a href=\"http://lib.csdn.net/base/mysql\" class=\"replace_word\" title=\"MySQL知识库\" target=\"_blank\" style=\"color:#df3434; font-weight:bold;\">MySQL</a>数据表存储带有中文字符的字符串时显示乱码。经过代码输出<a href=\"http://lib.csdn.net/base/softwaretest\" class=\"replace_word\" title=\"软件测试知识库\" target=\"_blank\" style=\"color:#df3434; font-weight:bold;\">测试</a>发现插入语句如下：</p><p style=\"text-align:justify;\">&nbsp;<img src=\"/ueditor/jsp/upload/image/20170803/1501750572733048237.png\" alt=\"\"/></p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; 在<a href=\"http://lib.csdn.net/base/mysql\" class=\"replace_word\" title=\"MySQL知识库\" target=\"_blank\" style=\"color:#df3434; font-weight:bold;\">数据库</a>内查询，发现存储的内容为乱码。</p><p style=\"text-align:justify;\">&nbsp;<img src=\"/ueditor/jsp/upload/image/20170803/1501750573042026047.png\" alt=\"\"/></p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; 尝试在<a href=\"http://lib.csdn.net/base/mysql\" class=\"replace_word\" title=\"MySQL知识库\" target=\"_blank\" style=\"color:#df3434; font-weight:bold;\">mysql</a>中直接插入语句。如下:</p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; INSERT INTO lm_user_med (uid,medid,medname,medprice,num)VALUES (&#39;u18353102088&#39;,&#39;TZ110204801&#39;,&#39;感冒灵颗粒1&#39;,&#39;8.00&#39;,&#39;1&#39;);</p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; 由上面的数据表可以看出，存储正常。而且在页面显示正常。</p><p style=\"text-align:justify;\">&nbsp;<img src=\"/ueditor/jsp/upload/image/20170803/1501750573586024226.png\" alt=\"\"/></p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; 为此，可以判定是数据表的字符编码出现了问题。</p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; 找了半天，原来问题出在这，可坑苦我了，连接数据库时未指定编码方式！！</p><p style=\"text-align:justify;\"><span style=\"color:rgb(42,0,255);\">&nbsp; &nbsp; &nbsp; jdbc:mysql://localhost:3308/lmapp?useUnicode=true&amp;characterEncoding=</span><span style=\"color:rgb(42,0,255);\">utf8</span></p><h2><a target=\"_blank\" name=\"t2\"></a><strong>注</strong></h2><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; 在进行数据库连接时一定要指定编码方式！(多么痛的领悟~)</p><p><br/></p>', 'web前端', '3');
INSERT INTO `blog` VALUES ('10', 'JSP页面中的pageEncoding和contentType两种属性', '本文介绍了在JSP页面中经常用的两种属性，分别是pageEncoding和contentType，希望对你有帮助，一起来看。      关于JSP页面中的pageEncoding和contentType两种属性的区别：      pageEncoding是jsp文件本身的编码。      contentT', '2017-08-03 17:00:39', '吴铭明', '0', '0', '&nbsp; 本文介绍了在<span style=\"font-family:Calibri;\">JSP</span><span style=\"font-family:宋体;\">页面中经常用的两种属性，分别是</span><span style=\"font-family:Calibri;\">pageEncoding</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Calibri;\">contentType</span><span style=\"font-family:宋体;\">，希望对你有帮助，一起来看。</span><p>&nbsp; &nbsp; &nbsp; 关于<span style=\"font-family:Calibri;\">JSP</span><span style=\"font-family:宋体;\">页面中的</span><span style=\"font-family:Calibri;\">pageEncoding</span><span style=\"font-family:宋体;\">和</span><span style=\"font-family:Calibri;\">contentType</span><span style=\"font-family:宋体;\">两种属性的区别：</span></p><p>&nbsp; &nbsp; &nbsp; pageEncoding<span style=\"font-family:宋体;\">是</span><span style=\"font-family:Calibri;\">jsp</span><span style=\"font-family:宋体;\">文件本身的编码</span>。</p><p>&nbsp; &nbsp; &nbsp; contentType<span style=\"font-family:宋体;\">的</span><span style=\"font-family:Calibri;\">charset</span><span style=\"font-family:宋体;\">是指服务器发送给客户端时的内容编码</span>。</p><p>&nbsp; &nbsp; &nbsp; JSP<span style=\"font-family:宋体;\">要经过两次的“编码”，第一阶段会用</span><span style=\"font-family:Calibri;\">pageEncoding</span><span style=\"font-family:宋体;\">，第二阶段会用</span><span style=\"font-family:Calibri;\">utf-8</span><span style=\"font-family:宋体;\">至</span><span style=\"font-family:Calibri;\">utf-8</span><span style=\"font-family:宋体;\">，第三阶段就是由</span><span style=\"font-family:Calibri;\">Tomcat</span><span style=\"font-family:宋体;\">出来的网页， 用的是</span><span style=\"font-family:Calibri;\">contentType</span><span style=\"font-family:宋体;\">。</span></p><p>&nbsp; &nbsp; &nbsp;</p>', 'jsp web前端', '3');
INSERT INTO `blog` VALUES ('11', '深入理解Java的接口和抽象类', '前言     对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用，但是实际则不然。今天我们就一起来学习一下Java中的接口和抽象类。抽象类     在了解抽象类之', '2017-08-03 17:02:10', '吴铭明', '1', '0', '<h2><strong>前言</strong></h2><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp;对于面向对象编程来说，抽象是它的一大特征之一。在<a href=\"http://lib.csdn.net/base/java\" class=\"replace_word\" title=\"Java 知识库\" target=\"_blank\" style=\"color:#df3434; font-weight:bold;\">Java</a>中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用，但是实际则不然。今天我们就一起来学习一下Java中的接口和抽象类。</p><h2><a target=\"_blank\" name=\"t2\"></a><strong>抽象类</strong></h2><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp;在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：</p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; abstract void fun();</p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp;抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。</p><p style=\"text-align:justify;\">&nbsp;\n &nbsp; \n&nbsp;下面要注意一个问题：在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。个人觉得这个属于钻牛角尖的问题吧，因为如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？所以暂且记住这个概念吧，不必去深究为什么。</p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp;[public] abstract class ClassName {</p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;abstract void fun();</p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp;}</p><p style=\"text-align: justify;\">&nbsp;\n &nbsp; \n&nbsp;从这里可以看出，抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。</p>', 'java 对象', '2');
INSERT INTO `blog` VALUES ('12', 'Java进阶(三十八)快速排序', '有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。 \n    假设我们现在对“6 1 2 7 9 3 4 5 10 \n8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。', '2017-08-03 17:05:00', '吴铭明', '0', '0', '<p>&nbsp;有没有既不浪费空间又可以快一点的排序<a href=\"http://lib.csdn.net/base/datastructure\" class=\"replace_word\" title=\"算法与数据结构知识库\" target=\"_blank\" style=\"color:#df3434; font-weight:bold;\">算法</a>呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。</p><p style=\"text-align:justify;\">&nbsp;\n &nbsp; &nbsp;假设我们现在对“6 1 2 7 9 3 4 5 10 \n8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：</p><p style=\"text-align:justify;\">3 1 2 5 4 6 9 7 10 8</p><p style=\"text-align:justify;\">&nbsp; &nbsp; &nbsp;在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？</p><p style=\"text-align:justify;\">&nbsp;\n &nbsp; &nbsp;方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 \n8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（数字8），指向数字。</p><p><br/></p>', 'java 排序', '2');
INSERT INTO `blog` VALUES ('13', '23种设计模式全解析', '设计模式的六大原则 总原则：开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象', '2017-08-03 17:51:37', '湛颖鸿', '0', '0', '<p>设计模式的六大原则 <br/>总原则：开闭原则（Open Close Principle） <br/>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 <br/>1、单一职责原则 <br/>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p><p>2、里氏替换原则（Liskov Substitution Principle） <br/>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 \n里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 \nLSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。——\n From Baidu 百科 <br/>历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p><p>3、依赖倒转原则（Dependence Inversion Principle） <br/>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p><p>4、接口隔离原则（Interface Segregation Principle） <br/>这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><p>5、迪米特法则（最少知道原则）（Demeter Principle） <br/>就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 <br/>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p><p><br/></p>', '设计模式', '2');
INSERT INTO `blog` VALUES ('14', '程序的内存分配之堆和栈的区别', '堆栈概述  在计算机领域，堆栈是一个不容忽视的概念，堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点： 堆，优先队列(priority \nqueue', '2017-08-03 17:53:16', '湛颖鸿', '0', '0', '<h1 id=\"堆栈概述\">堆栈概述</h1><p>  在计算机领域，堆栈是一个不容忽视的概念，堆栈是两种<a href=\"http://lib.csdn.net/base/datastructure\" class=\"replace_word\" title=\"算法与数据结构知识库\" target=\"_blank\" style=\"color:#df3434; font-weight:bold;\">数据结构</a>。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。</p><p><strong>要点：</strong> <br/><strong>堆</strong>，优先队列(priority \nqueue)；普通的队列是一种先进先出的数据结构（FIFO—First-In/First-Out），元素在队列尾追加，而从队列头删除，（例如：乘车排队，先来的排在前面先上车，后来的就要排的后面后上车;\n 哎，哎，你怎么插队呢，学没学过队列）；在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先取出。优先队列具有最高级先出 \n（largest-in，first-out）的行为特征。</p><p><strong>栈</strong>，先进后出(FILO—First-In/Last-Out)（例如：超市排队结账，大一点的超市收银台都是一段狭长的过道，本来下一个是你了，突然这个收银台说不结了，OK，栈形成了，排在前面的要后出去了）。</p><p><img src=\"http://localhost:8080/ssm/static/userImages/20170803/1501753984689028227.jpg\" title=\"1501753984689028227.jpg\" alt=\"5.jpg\"/></p>', '堆和栈', '2');
INSERT INTO `blog` VALUES ('15', '[Python]网络爬虫：爬虫框架Scrapy的第一个爬虫示例入门教程', '3.制作爬虫（Spider）制作爬虫，总体分两步：先爬再取。也就是说，首先你要获取整个网页的所有内容，然后再取出其中对你有用的部分。3.1爬Spider是用户自己编写的类，用来从一个域（或域组）中抓取信息。他们定义了用于下载的URL列表、跟踪链接的方案、解析网页内容的方式，以此来提取items。要建立一个Sp', '2017-08-03 17:54:52', '湛颖鸿', '0', '0', '<p><strong><span style=\"font-family:Microsoft YaHei; font-size:18px\">3.制作爬虫（Spider）</span></strong></p><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">制作爬虫，总体分两步：先爬再取。</span></p><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">也就是说，首先你要获取整个网页的所有内容，然后再取出其中对你有用的部分。</span></p><p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><strong>3.1爬</strong><br/></span></p><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">Spider是用户自己编写的类，用来从一个域（或域组）中抓取信息。</span></p><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">他们定义了用于下载的URL列表、跟踪链接的方案、解析网页内容的方式，以此来提取items。</span></p><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">要建立一个Spider，你必须用scrapy.spider.BaseSpider创建一个子类，并确定三个强制的属性：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">name：爬虫的识别名称，必须是唯一的，在不同的爬虫中你必须定义不同的名字。</span></p></li><li><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">start_urls：爬取的URL列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。<span class=\"link_title\"></span></span></p></li><li><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">parse()：解析的方法，调用的时候传入从每一个URL传回的Response对象作为唯一参数，负责解析并匹配抓取的数据(解析为item)，跟踪更多的URL。</span></p></li></ul><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">&nbsp;</span></p><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">这里可以参考宽度爬虫教程中提及的思想来帮助理解，<span class=\"link_title\">教程传送：<a target=\"_blank\" href=\"http://blog.csdn.net/pleasecallmewhy/article/details/18010015\">[Java] 知乎下巴第5集：使用HttpClient工具包和宽度爬虫</a>。</span></span><span style=\"font-family:Microsoft YaHei; font-size:18px\"><br/></span></p><p><span style=\"font-family:Microsoft YaHei; font-size:18px\">也就是把Url存储下来并依此为起点逐步扩散开去，抓取所有符合条件的网页Url存储起来继续爬取。</span></p><p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><br/></span></p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>', '爬虫', '11');
INSERT INTO `blog` VALUES ('16', 'Spring AOP 中pointcut expression表达式解析及配置', 'Pointcut是指那些方法需要被执行”AOP”,是由”Pointcut Expression”来描述的. Pointcut可以有下列方式来定义或者通过&& || 和!的方式进行组合.expression常用方法方法参数匹配args()@args()方法描述匹配execution()当前AOP代理对象类型匹配', '2017-08-03 17:56:23', '湛颖鸿', '2', '1', '<p>Pointcut是指那些方法需要被执行”AOP”,是由”Pointcut Expression”来描述的. <br/>Pointcut可以有下列方式来定义或者通过&amp;&amp; || 和!的方式进行组合.</p><h2 id=\"expression常用方法\"><a target=\"_blank\" name=\"t1\"></a>expression常用方法</h2><ul class=\" list-paddingleft-2\"><li><ul class=\" list-paddingleft-2\"><li><p>方法参数匹配</p></li></ul></li><li><p>args()</p></li><li><p>@args()</p></li></ul><hr/><ul class=\" list-paddingleft-2\"><li><ul class=\" list-paddingleft-2\"><li><p>方法描述匹配</p></li></ul></li><li><p>execution()</p></li></ul><hr/><ul class=\" list-paddingleft-2\"><li><ul class=\" list-paddingleft-2\"><li><p>当前AOP代理对象类型匹配</p></li></ul></li><li><p>this()</p></li></ul><hr/><ul class=\" list-paddingleft-2\"><li><ul class=\" list-paddingleft-2\"><li><p>目标类匹配</p></li></ul></li><li><p>target()</p></li><li><p>@target()</p></li><li><p>within()</p></li><li><p>@within()</p></li></ul><hr/><ul class=\" list-paddingleft-2\"><li><ul class=\" list-paddingleft-2\"><li><p>标有此注解的方法匹配</p></li></ul></li><li><p>@annotation()</p></li></ul><hr/><ul class=\" list-paddingleft-2\"><li><ul class=\" list-paddingleft-2\"><li><p>其中execution 是用的最多的,其格式为:</p></li></ul></li><li><p>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)throws-pattern?) <br/>returning type pattern,name pattern, and parameters pattern是必须的. <br/>ret-type-pattern:可以为*表示任何返回值,全路径的类名等. <br/>name-pattern:指定方法名, *代表所有 <br/>set*代表以set开头的所有方法. <br/>parameters pattern:指定方法参数(声明的类型),(..)代表所有参数,(*)代表一个参数 <br/>(*,String)代表第一个参数为任何值,第二个为String类型.</p></li></ul>', 'SpringAOP', '3');
INSERT INTO `blog` VALUES ('17', '活着', '的地地道道的', '2017-12-30 21:11:20', '张小花', '0', '0', '<p>的地地道道的<br/></p>', '生活', '17');
INSERT INTO `blog` VALUES ('18', '纯属测试', '测试看看', '2017-12-31 09:08:18', '张小花', '1', '0', '<p style=\"text-align: center;\"><img src=\"http://localhost:8080/static/userImages/20171231/1514682338051078998.png\" title=\"1514682338051078998.png\" alt=\"IMG_20171222_155149.png\" style=\"width: 605px; height: 240px;\" width=\"605\" height=\"240\"/></p><p>测试看看<br/></p>', '测试', '16');
INSERT INTO `blog` VALUES ('19', 'MyBatis使用动态SQL语句', '有时候，固定的SQL语句不能够满足我们的应用需求。我们需要在标准的基础上建立动态的查询语句。例如，在WEB的应用程序中，在标准的基础上，提供一个或多个输入选项或执行搜索。为了执行这些函数，我们需要在可选项的基础上建立动态查询语句。如果用户输入了多个标准的值，我们需要添加到WHERE的语句后。MyBatis提供', '2017-12-31 16:20:02', '张小花', '0', '0', '<p style=\"margin: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: &#39;microsoft yahei&#39;; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 35px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">有时候，固定的SQL语句不能够满足我们的应用需求。我们需要在标准的基础上建立动态的查询语句。例如，在WEB的应用程序中，在标准的基础上，提供一个或多个输入选项或执行搜索。为了执行这些函数，我们需要在可选项的基础上建立动态查询语句。如果用户输入了多个标准的值，我们需要添加到WHERE的语句后。MyBatis提供子这些参数这实现动态语言：&lt;if&gt;、&lt;choose&gt;、&lt;where&gt;、&lt;foreach&gt;和&lt;trim&gt;。</p><p><br/></p><br/>', 'sql语句', '6');
INSERT INTO `blog` VALUES ('20', 'Mybatis 批量插入引发的血案', 'mybatis 真的对动态 SQL 的 参数 或者 对象 数量设定了限制么？如果有那么原因何在？如果没有，那么为什么双方都那么确定呢？难道是 数据库 不同导致的？本着最小投入的原则，笔者开始了测试。手头现有 SQLServer 和 Mysql 就测这两个吧。脚本使用上述的简单脚本。', '2017-12-31 16:22:09', '张小花', '0', '0', '<p style=\"box-sizing: border-box; margin: 0px 0px 1.7em; padding: 0px; font-weight: normal; line-height: 27.2px; word-wrap: break-word; word-break: normal; color: rgb(63, 63, 63); font-family: &#39;microsoft yahei&#39;; font-size: 16px; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\"><code style=\"box-sizing: border-box; font-family: &#39;Source Code Pro&#39;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(63, 63, 63); white-space: nowrap; border-radius: 0px; background-color: rgba(128, 128, 128, 0.0745098);\">mybatis</code><span class=\"Apple-converted-space\">&nbsp;</span>真的对动态<span class=\"Apple-converted-space\">&nbsp;</span><strong style=\"box-sizing: border-box; font-weight: bold;\">SQL</strong><span class=\"Apple-converted-space\">&nbsp;</span>的<span class=\"Apple-converted-space\">&nbsp;</span><strong style=\"box-sizing: border-box; font-weight: bold;\">参数</strong><span class=\"Apple-converted-space\">&nbsp;</span>或者<span class=\"Apple-converted-space\">&nbsp;</span><strong style=\"box-sizing: border-box; font-weight: bold;\">对象</strong><span class=\"Apple-converted-space\">&nbsp;</span>数量设定了限制么？如果有那么原因何在？如果没有，那么为什么双方都那么确定呢？难道是<span class=\"Apple-converted-space\">&nbsp;</span><strong style=\"box-sizing: border-box; font-weight: bold;\">数据库</strong><span class=\"Apple-converted-space\">&nbsp;</span>不同导致的？本着最小投入的原则，笔者开始了测试。手头现有<span class=\"Apple-converted-space\">&nbsp;</span><code style=\"box-sizing: border-box; font-family: &#39;Source Code Pro&#39;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(63, 63, 63); white-space: nowrap; border-radius: 0px; background-color: rgba(128, 128, 128, 0.0745098);\">SQLServer</code><span class=\"Apple-converted-space\">&nbsp;</span>和<span class=\"Apple-converted-space\">&nbsp;</span><code style=\"box-sizing: border-box; font-family: &#39;Source Code Pro&#39;, monospace; font-size: 14.4px; padding: 2px 4px; color: rgb(63, 63, 63); white-space: nowrap; border-radius: 0px; background-color: rgba(128, 128, 128, 0.0745098);\">Mysql</code><span class=\"Apple-converted-space\">&nbsp;</span>就测这两个吧。脚本使用上述的简单脚本。</p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/><p><br/></p><p><br/></p>', '报错', '6');
INSERT INTO `blog` VALUES ('21', '阿里', '首先是系统：强大的深度学习训练平台和在线预测系统是深度学习应用的必要条件，目前我们的离线深度学习框架、在线深度学习框架和在线预测框架统一到tf，并实现了日志处理，特征抽取，模型训练和在线服务部署端到端的流程，极大提升了算法迭代效率；', '2018-01-02 09:19:12', '张小花', '0', '0', '<p><br/></p><br/><p style=\"box-sizing: border-box; margin: 0px; padding: 0px; font-weight: normal; word-wrap: break-word; word-break: normal; font-family: &#39;PingFang SC&#39;, &#39;Microsoft YaHei&#39;, SimHei, Arial, SimSun; font-size: 16px; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; min-height: 1em; color: rgb(62, 62, 62); line-height: 1.75em; background-color: rgb(255, 255, 255);\"><span style=\"box-sizing: border-box; margin: 0px; padding: 0px; font-weight: 400; font-size: 15px;\"><br style=\"box-sizing: border-box;\"/></span></p><p style=\"box-sizing: border-box; margin: 0px; padding: 0px; font-weight: normal; word-wrap: break-word; word-break: normal; font-family: &#39;PingFang SC&#39;, &#39;Microsoft YaHei&#39;, SimHei, Arial, SimSun; font-size: 16px; font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; min-height: 1em; color: rgb(62, 62, 62); line-height: 1.75em; background-color: rgb(255, 255, 255);\"><strong style=\"box-sizing: border-box; font-weight: bold;\"><span style=\"box-sizing: border-box; margin: 0px; padding: 0px; font-weight: 400; font-size: 15px;\">首先是系统：</span></strong><span style=\"box-sizing: border-box; margin: 0px; padding: 0px; font-weight: 400; font-size: 15px;\">强大的深度学习训练平台和在线预测系统是深度学习应用的必要条件，目前我们的离线深度学习框架、在线深度学习框架和在线预测框架统一到tf，并实现了日志处理，特征抽取，模型训练和在线服务部署端到端的流程，极大提升了算法迭代效率；</span></p><p><img src=\"http://localhost:8080/static/userImages/20180102/1514855549090096702.png\" title=\"1514855549090096702.png\" alt=\"IMG_20171222_155233.png\"/></p>', '阿里', '3');
INSERT INTO `blog` VALUES ('22', '111', '整个反射中最为重要的组成就是java.lang.Class<T>类 要想取得这个类的实例化对象有三种方式1：如果你已经得到了某个对象，但是你想获取这个对象的 Class 对象，Object类之中存在有一个getClass（）方法：public final Class<?> getClass();   (此方法', '2018-01-02 21:21:40', '张小花', '0', '0', '<p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">整个反射中最为重要的组成就是</span>java.lang.Class&lt;T&gt;<span style=\"font-family:宋体\">类</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;<span style=\"font-family:宋体\">要想取得这个类的实例化对象有三种方式</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">1<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你已经得到了某个对象，但是你想获取这个对象的</span> Class 对象，</span><span style=\";font-family:宋体;font-size:14px\">Object<span style=\"font-family:宋体\">类之中存在有一个</span><span style=\"font-family:Calibri\">getClass</span><span style=\"font-family:宋体\">（）方法：</span><span style=\"font-family:Calibri\">public final Class&lt;?&gt; getClass();</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;(<span style=\"font-family:宋体\">此方法不能被子类所覆写，而且所有类的实例化对象都可以调用</span><span style=\"font-family:Calibri\">) &nbsp;</span></span><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\"><span style=\"font-family:宋体\">少用</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">2:</span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期知道一个类的名字的话</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>“包<span style=\"font-family:Calibri\">.</span><span style=\"font-family:宋体\">类</span><span style=\"font-family:Calibri\">.class</span><span style=\"font-family:宋体\">”的形式实例化</span><span style=\"font-family:Calibri\">Class</span><span style=\"font-family:宋体\">类对象；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（例如：</span>java.util.Date.class,<span style=\"font-family:宋体\">在一些开源框架之中会大量使用到，例如</span><span style=\"font-family:Calibri\">Hibernat e</span><span style=\"font-family:宋体\">）</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">3<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期获取不到目标类型，但是你知道它的完整类路径，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>Class<span style=\"font-family:宋体\">类之中提供的</span><span style=\"font-family:Calibri\">forName()</span><span style=\"font-family:宋体\">方法；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（主要可以用于工厂类上，设计上</span>JDBC<span style=\"font-family:宋体\">的驱动加载使用此模式）</span></span></p><p><br/></p><br/><br/>', '社发放', '17');
INSERT INTO `blog` VALUES ('23', '2222', '整个反射中最为重要的组成就是java.lang.Class<T>类 要想取得这个类的实例化对象有三种方式1：如果你已经得到了某个对象，但是你想获取这个对象的 Class 对象，Object类之中存在有一个getClass（）方法：public final Class<?> getClass();   (此方法', '2018-01-02 21:36:21', '张小花', '0', '0', '<p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">整个反射中最为重要的组成就是</span>java.lang.Class&lt;T&gt;<span style=\"font-family:宋体\">类</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;<span style=\"font-family:宋体\">要想取得这个类的实例化对象有三种方式</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">1<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你已经得到了某个对象，但是你想获取这个对象的</span> Class 对象，</span><span style=\";font-family:宋体;font-size:14px\">Object<span style=\"font-family:宋体\">类之中存在有一个</span><span style=\"font-family:Calibri\">getClass</span><span style=\"font-family:宋体\">（）方法：</span><span style=\"font-family:Calibri\">public final Class&lt;?&gt; getClass();</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;(<span style=\"font-family:宋体\">此方法不能被子类所覆写，而且所有类的实例化对象都可以调用</span><span style=\"font-family:Calibri\">) &nbsp;</span></span><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\"><span style=\"font-family:宋体\">少用</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">2:</span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期知道一个类的名字的话</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>“包<span style=\"font-family:Calibri\">.</span><span style=\"font-family:宋体\">类</span><span style=\"font-family:Calibri\">.class</span><span style=\"font-family:宋体\">”的形式实例化</span><span style=\"font-family:Calibri\">Class</span><span style=\"font-family:宋体\">类对象；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（例如：</span>java.util.Date.class,<span style=\"font-family:宋体\">在一些开源框架之中会大量使用到，例如</span><span style=\"font-family:Calibri\">Hibernat e</span><span style=\"font-family:宋体\">）</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">3<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期获取不到目标类型，但是你知道它的完整类路径，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>Class<span style=\"font-family:宋体\">类之中提供的</span><span style=\"font-family:Calibri\">forName()</span><span style=\"font-family:宋体\">方法；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（主要可以用于工厂类上，设计上</span>JDBC<span style=\"font-family:宋体\">的驱动加载使用此模式）</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">特点：程序没有很强的严谨性，操作类可以不存在。</span></span></p><p><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\"><span style=\"font-family:宋体\">使用</span>new<span style=\"font-family:宋体\">实例化对象以及使用反射实例化对象有什么区别？</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">如果只是一个单纯的类进行对象的实例化，那么两者的区别不大，如果非需要强调区别，使用反射实例化对象，它的灵活度更高，因为只需要传入</span>“包<span style=\"font-family:Calibri\">.</span><span style=\"font-family:宋体\">类”名称的字符串就可以取得实例化对象，要比严谨性的</span><span style=\"font-family:Calibri\">new</span><span style=\"font-family:宋体\">要宽松很多。</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">如果说现在是一个子类需要为父接口进行对象实例化，那么如果使用关键字</span>new<span style=\"font-family:宋体\">，会造成接口对象的耦合性增加的问题，因为一个接口在使用中就与固定的一个子类进行绑定了，而最早的解耦合的方式是利用工厂设计模式，一个工厂类可以使用所有接口子类的扩展要求，则可以利用反射完成。</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">整个反射中最为重要的组成就是</span>java.lang.Class&lt;T&gt;<span style=\"font-family:宋体\">类</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;<span style=\"font-family:宋体\">要想取得这个类的实例化对象有三种方式</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">1<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你已经得到了某个对象，但是你想获取这个对象的</span> Class 对象，</span><span style=\";font-family:宋体;font-size:14px\">Object<span style=\"font-family:宋体\">类之中存在有一个</span><span style=\"font-family:Calibri\">getClass</span><span style=\"font-family:宋体\">（）方法：</span><span style=\"font-family:Calibri\">public final Class&lt;?&gt; getClass();</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;(<span style=\"font-family:宋体\">此方法不能被子类所覆写，而且所有类的实例化对象都可以调用</span><span style=\"font-family:Calibri\">) &nbsp;</span></span><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\"><span style=\"font-family:宋体\">少用</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">2:</span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期知道一个类的名字的话</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>“包<span style=\"font-family:Calibri\">.</span><span style=\"font-family:宋体\">类</span><span style=\"font-family:Calibri\">.class</span><span style=\"font-family:宋体\">”的形式实例化</span><span style=\"font-family:Calibri\">Class</span><span style=\"font-family:宋体\">类对象；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（例如：</span>java.util.Date.class,<span style=\"font-family:宋体\">在一些开源框架之中会大量使用到，例如</span><span style=\"font-family:Calibri\">Hibernat e</span><span style=\"font-family:宋体\">）</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">3<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期获取不到目标类型，但是你知道它的完整类路径，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>Class<span style=\"font-family:宋体\">类之中提供的</span><span style=\"font-family:Calibri\">forName()</span><span style=\"font-family:宋体\">方法；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（主要可以用于工厂类上，设计上</span>JDBC<span style=\"font-family:宋体\">的驱动加载使用此模式）</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">特点：程序没有很强的严谨性，操作类可以不存在。</span></span></p><p><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\"><span style=\"font-family:宋体\">使用</span>new<span style=\"font-family:宋体\">实例化对象以及使用反射实例化对象有什么区别？</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">如果只是一个单纯的类进行对象的实例化，那么两者的区别不大，如果非需要强调区别，使用反射实例化对象，它的灵活度更高，因为只需要传入</span>“包<span style=\"font-family:Calibri\">.</span><span style=\"font-family:宋体\">类”名称的字符串就可以取得实例化对象，要比严谨性的</span><span style=\"font-family:Calibri\">new</span><span style=\"font-family:宋体\">要宽松很多。</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">如果说现在是一个子类需要为父接口进行对象实例化，那么如果使用关键字</span>new<span style=\"font-family:宋体\">，会造成接口对象的耦合性增加的问题，因为一个接口在使用中就与固定的一个子类进行绑定了，而最早的解耦合的方式是利用工厂设计模式，一个工厂类可以使用所有接口子类的扩展要求，则可以利用反射完成。</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">整个反射中最为重要的组成就是</span>java.lang.Class&lt;T&gt;<span style=\"font-family:宋体\">类</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;<span style=\"font-family:宋体\">要想取得这个类的实例化对象有三种方式</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">1<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你已经得到了某个对象，但是你想获取这个对象的</span> Class 对象，</span><span style=\";font-family:宋体;font-size:14px\">Object<span style=\"font-family:宋体\">类之中存在有一个</span><span style=\"font-family:Calibri\">getClass</span><span style=\"font-family:宋体\">（）方法：</span><span style=\"font-family:Calibri\">public final Class&lt;?&gt; getClass();</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;(<span style=\"font-family:宋体\">此方法不能被子类所覆写，而且所有类的实例化对象都可以调用</span><span style=\"font-family:Calibri\">) &nbsp;</span></span><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\"><span style=\"font-family:宋体\">少用</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">2:</span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期知道一个类的名字的话</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>“包<span style=\"font-family:Calibri\">.</span><span style=\"font-family:宋体\">类</span><span style=\"font-family:Calibri\">.class</span><span style=\"font-family:宋体\">”的形式实例化</span><span style=\"font-family:Calibri\">Class</span><span style=\"font-family:宋体\">类对象；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（例如：</span>java.util.Date.class,<span style=\"font-family:宋体\">在一些开源框架之中会大量使用到，例如</span><span style=\"font-family:Calibri\">Hibernat e</span><span style=\"font-family:宋体\">）</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">3<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期获取不到目标类型，但是你知道它的完整类路径，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>Class<span style=\"font-family:宋体\">类之中提供的</span><span style=\"font-family:Calibri\">forName()</span><span style=\"font-family:宋体\">方法；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（主要可以用于工厂类上，设计上</span>JDBC<span style=\"font-family:宋体\">的驱动加载使用此模式）</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">特点：程序没有很强的严谨性，操作类可以不存在。</span></span></p><p><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\"><span style=\"font-family:宋体\">使用</span>new<span style=\"font-family:宋体\">实例化对象以及使用反射实例化对象有什么区别？</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">如果只是一个单纯的类进行对象的实例化，那么两者的区别不大，如果非需要强调区别，使用反射实例化对象，它的灵活度更高，因为只需要传入</span>“包<span style=\"font-family:Calibri\">.</span><span style=\"font-family:宋体\">类”名称的字符串就可以取得实例化对象，要比严谨性的</span><span style=\"font-family:Calibri\">new</span><span style=\"font-family:宋体\">要宽松很多。</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">如果说现在是一个子类需要为父接口进行对象实例化，那么如果使用关键字</span>new<span style=\"font-family:宋体\">，会造成接口对象的耦合性增加的问题，因为一个接口在使用中就与固定的一个子类进行绑定了，而最早的解耦合的方式是利用工厂设计模式，一个工厂类可以使用所有接口子类的扩展要求，则可以利用反射完成。</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">整个反射中最为重要的组成就是</span>java.lang.Class&lt;T&gt;<span style=\"font-family:宋体\">类</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;<span style=\"font-family:宋体\">要想取得这个类的实例化对象有三种方式</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">1<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你已经得到了某个对象，但是你想获取这个对象的</span> Class 对象，</span><span style=\";font-family:宋体;font-size:14px\">Object<span style=\"font-family:宋体\">类之中存在有一个</span><span style=\"font-family:Calibri\">getClass</span><span style=\"font-family:宋体\">（）方法：</span><span style=\"font-family:Calibri\">public final Class&lt;?&gt; getClass();</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;(<span style=\"font-family:宋体\">此方法不能被子类所覆写，而且所有类的实例化对象都可以调用</span><span style=\"font-family:Calibri\">) &nbsp;</span></span><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\"><span style=\"font-family:宋体\">少用</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">2:</span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期知道一个类的名字的话</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>“包<span style=\"font-family:Calibri\">.</span><span style=\"font-family:宋体\">类</span><span style=\"font-family:Calibri\">.class</span><span style=\"font-family:宋体\">”的形式实例化</span><span style=\"font-family:Calibri\">Class</span><span style=\"font-family:宋体\">类对象；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（例如：</span>java.util.Date.class,<span style=\"font-family:宋体\">在一些开源框架之中会大量使用到，例如</span><span style=\"font-family:Calibri\">Hibernat e</span><span style=\"font-family:宋体\">）</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">3<span style=\"font-family:宋体\">：</span></span><span style=\";font-family:宋体;font-size:16px\"><span style=\"font-family:宋体\">如果你在编译期获取不到目标类型，但是你知道它的完整类路径，</span></span><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">利用</span>Class<span style=\"font-family:宋体\">类之中提供的</span><span style=\"font-family:Calibri\">forName()</span><span style=\"font-family:宋体\">方法；</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">（主要可以用于工厂类上，设计上</span>JDBC<span style=\"font-family:宋体\">的驱动加载使用此模式）</span></span></p><p><span style=\";font-family:宋体;font-size:14px\"><span style=\"font-family:宋体\">特点：程序没有很强的严谨性，操作类可以不存在。</span></span></p><p><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(255,0,0);font-size:14px\"><span style=\"font-family:宋体\">使用</span>new<span style=\"font-family:宋体\">实例化对象以及使用反射实例化对象有什么区别？</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">如果只是一个单纯的类进行对象的实例化，那么两者的区别不大，如果非需要强调区别，使用反射实例化对象，它的灵活度更高，因为只需要传入</span>“包<span style=\"font-family:Calibri\">.</span><span style=\"font-family:宋体\">类”名称的字符串就可以取得实例化对象，要比严谨性的</span><span style=\"font-family:Calibri\">new</span><span style=\"font-family:宋体\">要宽松很多。</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">如果说现在是一个子类需要为父接口进行对象实例化，那么如果使用关键字</span>new<span style=\"font-family:宋体\">，会造成接口对象的耦合性增加的问题，因为一个接口在使用中就与固定的一个子类进行绑定了，而最早的解耦合的方式是利用工厂设计模式，一个工厂类可以使用所有接口子类的扩展要求，则可以利用反射完成。</span></span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&nbsp;</span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;3.<span style=\"font-family:宋体\">制作爬虫（</span><span style=\"font-family:Calibri\">Spider</span><span style=\"font-family:宋体\">）</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;</span><span style=\"font-family:宋体\">制作爬虫，总体分两步：先爬再取。</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;</span><span style=\"font-family:宋体\">也就是说，首先你要获取整个网页的所有内容，然后再取出其中对你有用的部分。</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;&lt;strong&gt;3.1</span><span style=\"font-family:宋体\">爬</span><span style=\"font-family:Calibri\">&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;Spider</span><span style=\"font-family:宋体\">是用户自己编写的类，用来从一个域（或域组）中抓取信息。</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;</span><span style=\"font-family:宋体\">他们定义了用于下载的</span><span style=\"font-family:Calibri\">URL</span><span style=\"font-family:宋体\">列表、跟踪链接的方案、解析网页内容的方式，以此来提取</span><span style=\"font-family:Calibri\">items</span><span style=\"font-family:宋体\">。</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;</span><span style=\"font-family:宋体\">要建立一个</span><span style=\"font-family:Calibri\">Spider</span><span style=\"font-family:宋体\">，你必须用</span><span style=\"font-family:Calibri\">scrapy.spider.BaseSpider</span><span style=\"font-family:宋体\">创建一个子类，并确定三个强制的属性：</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;name</span><span style=\"font-family:宋体\">：爬虫的识别名称，必须是唯一的，在不同的爬虫中你必须定义不同的名字。</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;start_urls</span><span style=\"font-family:宋体\">：爬取的</span><span style=\"font-family:Calibri\">URL</span><span style=\"font-family:宋体\">列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些</span><span style=\"font-family:Calibri\">urls</span><span style=\"font-family:宋体\">开始。其他子</span><span style=\"font-family:Calibri\">URL</span><span style=\"font-family:宋体\">将会从这些起始</span><span style=\"font-family:Calibri\">URL</span><span style=\"font-family:宋体\">中继承性生成。</span><span style=\"font-family:Calibri\">&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;parse()</span><span style=\"font-family:宋体\">：解析的方法，调用的时候传入从每一个</span><span style=\"font-family:Calibri\">URL</span><span style=\"font-family:宋体\">传回的</span><span style=\"font-family:Calibri\">Response</span><span style=\"font-family:宋体\">对象作为唯一参数，负责解析并匹配抓取的数据</span><span style=\"font-family:Calibri\">(</span><span style=\"font-family:宋体\">解析为</span><span style=\"font-family:Calibri\">item)</span><span style=\"font-family:宋体\">，跟踪更多的</span><span style=\"font-family:Calibri\">URL</span><span style=\"font-family:宋体\">。</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;&nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;</span><span style=\"font-family:宋体\">这里可以参考宽度爬虫教程中提及的思想来帮助理解，</span><span style=\"font-family:Calibri\">&lt;span&gt;</span><span style=\"font-family:宋体\">教程传送：</span><span style=\"font-family:Calibri\">&lt;a target=&quot;_blank&quot; href=&quot;http://blog.csdn.net/pleasecallmewhy/article/details/18010015&quot;&gt;[Java] </span><span style=\"font-family:宋体\">知乎下巴第</span><span style=\"font-family:Calibri\">5</span><span style=\"font-family:宋体\">集：使用</span><span style=\"font-family:Calibri\">HttpClient</span><span style=\"font-family:宋体\">工具包和宽度爬虫</span><span style=\"font-family:Calibri\">&lt;/a&gt;</span><span style=\"font-family:宋体\">。</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;</span><span style=\"font-family:宋体\">也就是把</span><span style=\"font-family:Calibri\">Url</span><span style=\"font-family:宋体\">存储下来并依此为起点逐步扩散开去，抓取所有符合条件的网页</span><span style=\"font-family:Calibri\">Url</span><span style=\"font-family:宋体\">存储起来继续爬取。</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family:Microsoft YaHei; font-size:18px&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;img src=&quot;http://img.baidu.com/hi/jx2/j_0013.gif&quot;/&gt;</span></span></p><p><span style=\";font-family:宋体;color:rgb(0,0,0);font-size:14px\">&lt;p&gt;&lt;span style=&quot;;font-family:<span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">整个反射中最为重要的组成就是</span><span style=\"font-family:Calibri\">&lt;/span&gt;java.lang.Class&lt;T&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">类</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;&nbsp;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">要想取得这个类的实例化对象有三种方式</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;1&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">：</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:16px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">如果你已经得到了某个对象，但是你想获取这个对象的</span><span style=\"font-family:Calibri\">&lt;/span&gt; Class </span><span style=\"font-family:宋体\">对象，</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;Object&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">类之中存在有一个</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;span style=&quot;font-family:Calibri&quot;&gt;getClass&lt;/span&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">（）方法：</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;span style=&quot;font-family:Calibri&quot;&gt;public final Class&lt;?&gt; getClass();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;&nbsp;&nbsp;&nbsp;(&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">此方法不能被子类所覆写，而且所有类的实例化对象都可以调用</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;span style=&quot;font-family:Calibri&quot;&gt;) &nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;color:rgb(255,0,0);font-size:14px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">少用</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;2:&lt;/span&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:16px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">如果你在编译期知道一个类的名字的话</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:16px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">，</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">利用</span><span style=\"font-family:Calibri\">&lt;/span&gt;</span><span style=\"font-family:宋体\">“包</span><span style=\"font-family:Calibri\">&lt;span style=&quot;font-family:Calibri&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">类</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;span style=&quot;font-family:Calibri&quot;&gt;.class&lt;/span&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">”的形式实例化</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;span style=&quot;font-family:Calibri&quot;&gt;Class&lt;/span&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">类对象；</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">（例如：</span><span style=\"font-family:Calibri\">&lt;/span&gt;java.util.Date.class,&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">在一些开源框架之中会大量使用到，例如</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;span style=&quot;font-family:Calibri&quot;&gt;Hibernat e&lt;/span&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">）</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;3&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">：</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:16px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">如果你在编译期获取不到目标类型，但是你知道它的完整类路径，</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">利用</span><span style=\"font-family:Calibri\">&lt;/span&gt;Class&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">类之中提供的</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;span style=&quot;font-family:Calibri&quot;&gt;forName()&lt;/span&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">方法；</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">;font-size:14px&quot;&gt;&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">（主要可以用于工厂类上，设计上</span><span style=\"font-family:Calibri\">&lt;/span&gt;JDBC&lt;span style=&quot;font-family:</span><span style=\"font-family:宋体\">宋体</span><span style=\"font-family:Calibri\">&quot;&gt;</span><span style=\"font-family:宋体\">的驱动加载使用此模式）</span><span style=\"font-family:Calibri\">&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;</span></span></p><p><br/></p>', '2', '17');

-- ----------------------------
-- Table structure for `comment`
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `cid` int(11) NOT NULL AUTO_INCREMENT,
  `author` varchar(255) COLLATE utf8_general_mysql500_ci DEFAULT NULL COMMENT '评论人',
  `content` varchar(255) COLLATE utf8_general_mysql500_ci DEFAULT NULL,
  `commentDate` datetime DEFAULT NULL,
  `state` int(11) DEFAULT NULL,
  `bid` int(11) DEFAULT NULL,
  PRIMARY KEY (`cid`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 COLLATE=utf8_general_mysql500_ci;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('1', '赖红', '测试', '2017-07-26 22:43:20', '1', '6');
INSERT INTO `comment` VALUES ('2', '赖红', '测试凤飞飞', '2017-07-26 22:45:41', '1', '6');
INSERT INTO `comment` VALUES ('3', '赖红', '第三次测试', '2017-07-26 23:04:26', '1', '6');
INSERT INTO `comment` VALUES ('4', '赖红', '第四次测试', '2017-07-26 23:15:48', '1', '6');
INSERT INTO `comment` VALUES ('5', '赖红', '第五次测试', '2017-07-26 23:18:34', '1', '6');
INSERT INTO `comment` VALUES ('8', '吴铭明', 'java之强大强大', '2017-08-03 17:08:53', '1', '6');
INSERT INTO `comment` VALUES ('10', '湛颖鸿', '学习学习再学习', '2017-08-03 22:54:49', '1', '16');

-- ----------------------------
-- Table structure for `link`
-- ----------------------------
DROP TABLE IF EXISTS `link`;
CREATE TABLE `link` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `linkName` varchar(255) DEFAULT NULL,
  `linkUrl` varchar(255) DEFAULT NULL,
  `orderNo` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of link
-- ----------------------------
INSERT INTO `link` VALUES ('1', 'java知识分享网', 'http://www.java1234.com/', '1');
INSERT INTO `link` VALUES ('2', '传智播客（学习视频）', 'http://www.itcast.cn/', '2');
INSERT INTO `link` VALUES ('3', '尚硅谷(学习视频)', 'http://www.atguigu.com/', '3');
INSERT INTO `link` VALUES ('4', 'java知识分享网', 'http://www.java1234.com/', '4');
INSERT INTO `link` VALUES ('5', '传智播客（学习视频）', 'http://www.itcast.cn/', '5');
INSERT INTO `link` VALUES ('6', '尚硅谷(学习视频)', 'http://www.atguigu.com/', '6');
INSERT INTO `link` VALUES ('7', '传智播客（学习视频）', 'http://www.itcast.cn/', '7');
INSERT INTO `link` VALUES ('8', '尚硅谷(学习视频)', 'http://www.atguigu.com/', '8');

-- ----------------------------
-- Table structure for `type`
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type` (
  `typeId` int(11) NOT NULL AUTO_INCREMENT,
  `typeName` varchar(255) DEFAULT NULL,
  `describes` varchar(255) DEFAULT '类型描述',
  `imageName` varchar(255) DEFAULT NULL COMMENT '标识符号',
  `blogCount` int(11) DEFAULT NULL,
  `orderNo` int(11) DEFAULT NULL,
  PRIMARY KEY (`typeId`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES ('2', 'java', '具有简单性、面向对象、分布式、健壮性、安全性、平台独立性等等。', '20180120052442.jpg', '6', '2');
INSERT INTO `type` VALUES ('3', 'web', '一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。', '20171231100115.png', null, '3');
INSERT INTO `type` VALUES ('4', 'mysql', '专为数据库而建立的操作命令集，是一种功能齐全的数据库语言，是所有关系数据库的公共语言。', '20171231100132.png', '1', '4');
INSERT INTO `type` VALUES ('5', 'HTML', '不一样的前端页面由我开始', '20171231100150.png', null, '5');
INSERT INTO `type` VALUES ('6', 'Mybatis', '为后台带来福音，简洁的分页跟通用mapper', '20171231100203.png', null, '6');
INSERT INTO `type` VALUES ('7', 'SQL server', '不一样的数据库', '20171231100222.png', null, '7');
INSERT INTO `type` VALUES ('11', 'Python', 'Python之旅', '20171231100254.jpg', null, '11');
INSERT INTO `type` VALUES ('12', 'Oracle', '不开源数据库', '20171231100311.jpg', null, '12');
INSERT INTO `type` VALUES ('13', 'Ceph', '运维之旅', '20171231100327.jpg', null, '13');
INSERT INTO `type` VALUES ('14', 'Linux', '运维之强大', '20171231100340.jpg', null, '14');
INSERT INTO `type` VALUES ('16', '测试', '测试测试', '20171231100400.jpg', null, '16');
INSERT INTO `type` VALUES ('17', '生活', '世界很大，生活很忙', '20171229111414.jpg', null, null);

-- ----------------------------
-- Table structure for `user`
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `uid` int(11) NOT NULL AUTO_INCREMENT,
  `uname` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `sex` varchar(11) DEFAULT NULL,
  `phone` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `sign` varchar(255) DEFAULT NULL COMMENT '个性签名',
  `proFile` varchar(2000) DEFAULT NULL COMMENT '个人简介',
  `imageName` varchar(255) DEFAULT NULL COMMENT '头像',
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', '赖红', '96e79218965eb72c92a549dd5a330112', '女', '17765602540', '1185630400@qq.com', '一个人可以走很快，一群人可以走很远！', '<p><img src=\"http://img.baidu.com/hi/face/i_f46.gif\"/><span style=\"font-size: 20px;\"></span><img src=\"http://img.baidu.com/hi/tsj/t_0028.gif\"/></p><p><br/></p><p><br/><span style=\"font-size: 20px;\"></span></p><p><br/></p>', '20180316093931.jpg');
INSERT INTO `user` VALUES ('8', '陈家小k', 'e10adc3949ba59abbe56e057f20f883e', '女', '13415843978', '1847412191@qq.com', null, null, null);
INSERT INTO `user` VALUES ('9', '湛肖', '71b3b26aaa319e0cdf6fdb8429c112b0', '男', '18718934520', '98756575@qq.com', null, null, null);
INSERT INTO `user` VALUES ('10', '陈静', 'c2610f901735286e712ef0a11df1535b', '女', '13692571283', '1249629019@qq.com', null, null, null);
INSERT INTO `user` VALUES ('11', '陈坤', '96e79218965eb72c92a549dd5a330112', '男', '18718934520', '2953349339@qq.com', null, null, null);
INSERT INTO `user` VALUES ('12', '湛颖鸿', 'be438f57516bdc665a29f3e79538c2a0', '男', '18718934520', '85642653@qq.com', '别让自己配不上野心也辜负了曾经经历的一切！', '<p>很想很刚刚回家<img src=\"http://localhost:8080/ssm/static/userImages/20170720/1500537849769085252.jpg\" title=\"1500537849769085252.jpg\" alt=\"2.jpg\"/>想很想<img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/></p>', '20170726124034.jpg');
INSERT INTO `user` VALUES ('15', '张三', '1a100d2c0dab19c4430e7d73762b3423', '男', '15767375403', '854875636@qq.com', null, null, null);
INSERT INTO `user` VALUES ('16', '任玉华', '73882ab1fa529d7273da0db6b49cc4f3', '女', '15112019616', '2953349339@qq.com', null, null, null);
INSERT INTO `user` VALUES ('17', '李四', '6dd9aa0b0606270d0875acb21546bedb', '男', '18718934520', '658965845@qq.com', null, null, null);
INSERT INTO `user` VALUES ('18', '吴铭明', '5b1b68a9abf4d2cd155c81a9225fd158', '女', '17765602533', '1792545884@qq.com', '太阳当空照，我去上学校！爱学习，爱劳动！', '<p><em><span style=\"border: medium none; text-decoration: none;\">爱学习爱劳动争当好公民</span></em><br/></p>', '20170803045351.jpg');
INSERT INTO `user` VALUES ('19', '王五', 'e10adc3949ba59abbe56e057f20f883e', '男', '13143197552', 'kwe.781567776@qq.com', null, null, null);
INSERT INTO `user` VALUES ('20', '张小花', '96e79218965eb72c92a549dd5a330112', '女', '17796354214', '896745632@qq.com', null, null, null);
INSERT INTO `user` VALUES ('21', '张小花2', 'e3ceb5881a0a1fdaad01296d7554868d', '女', '19965425487', '858563542@qq.com', null, null, null);
